---
title: My Journey in Creating a Custom Operating System
date: 2024-10-16
description: Sharing the journey and learning experiences of building a custom operating system, MoldOS.
tags: ["operating system", "MoldOS", "development journey"]
image: "/images/posts/25.jpg"
categories: ["code"]
author: Sujal Choudhari
---

# Building MoldOS: My Journey in Creating a Custom Operating System

Hello, fellow tech enthusiasts! I'm excited to share with you my ongoing journey of building my very own operating system, which I've now named MoldOS. This project has been an incredible learning experience, and I've been documenting my progress through daily devlogs on Twitter. Today, I want to give you a comprehensive update on how far I've come and what I've learned along the way.

## Project Goals

When I started this ambitious project, I set a few key goals for myself:

1.  Use tutorials only for the basics
2.  Write original code instead of copying
3.  Create something that feels uniquely mine

With these goals in mind and armed with the guide "Building an OS from Nanobyte," I dove headfirst into the world of OS development.

## Understanding the Basics: BIOS, Bootloader, and Kernel

Before diving into the achievements, let me briefly explain some fundamental concepts I've learned:

### BIOS and Bootloader

The BIOS (Basic Input/Output System) is the first software that runs when a computer starts. It performs some initial checks and then looks for a bootloader on the storage devices. The bootloader is a small program that loads the operating system kernel into memory.

In my case, I created a custom bootloader that the BIOS loads from the first sector of the disk. This bootloader is responsible for:

1.  Setting up a basic environment
2.  Loading the kernel from the disk into memory
3.  Switching the CPU to protected mode
4.  Jumping to the kernel code

### Kernel

The kernel is the core of the operating system. It manages system resources, handles hardware interactions, and provides essential services to other software. My kernel, initially very basic, grew to include features like memory management, device drivers, and a simple file system.

## Early Achievements

In the initial stages of the project, which I originally called SmallOS, I hit several important milestones:

1.  **FAT12 Support**: I successfully added FAT12 support to the bootloader, enabling it to locate and run the kernel. FAT12 is a simple file system often used in bootloaders due to its simplicity. While FAT32 is more common for larger drives, FAT12 was perfect for my initial needs.
2.  **"Hello World"**: Getting the kernel to load and display a simple "Hello World" message was a significant accomplishment. This involved setting up a basic VGA text mode driver to write to the screen buffer, which has a resolution of 80x25 characters.
3.  **Compiler Switch**: After some experimentation, I switched from the Open Watcom C compiler to GCC, which seemed more suitable for long-term development.
4.  **Basic CLI**: I implemented printf and scanf functionality and built a basic command-line interface.

These early wins were incredibly motivating and set the stage for more complex development.

## Switching Gears: Enter MoldOS

As the project evolved, I made some significant changes and additions:

1.  **Rust Migration**: I decided to rebuild the OS using Rust, a language known for its safety and performance. While challenging, this switch has been an exciting learning opportunity.
2.  **Interrupt Descriptor Table (IDT)**: I successfully implemented the IDT, a crucial step in handling system errors and making the OS more stable and reliable. The IDT is a data structure that associates each interrupt or exception with a handler function. When an interrupt occurs, the CPU uses the IDT to find and execute the appropriate handler.
3.  **Keyboard Input**: I added functionality to handle keyboard inputs, allowing keypresses to display on the screen. This involved writing a driver for the keyboard controller and setting up the appropriate interrupt handler.
4.  **Pagination**: I implemented pagination with L1, L2, and L3 caches, further optimizing the system's performance. Pagination allows the OS to use virtual memory, mapping virtual addresses to physical addresses. The multi-level cache system works like this:
    - L1 Cache: Smallest and fastest, typically built into the CPU core
    - L2 Cache: Larger but slightly slower, often shared between CPU cores
    - L3 Cache: Largest but slowest of the three, shared among all coresThis caching system significantly speeds up memory access by keeping frequently used data close to the CPU.
5.  **Full File System Support**: This was a major milestone, opening up new possibilities for file management within MoldOS.

## Blending Passions: Game Development in MoldOS

To keep things interesting and merge my love for game development with OS creation, I've started working on a dungeon crawler game specifically for MoldOS. This project within a project has been incredibly motivating and helps showcase the capabilities of my custom OS.

Developing a game for MoldOS involves writing custom graphics drivers to manipulate the VGA buffer directly. The standard text mode provides a 80x25 character grid, but with some tweaking, I've managed to create a more graphical environment for the game.

## Learning and Growth

This journey has been about so much more than just coding. It's taught me the importance of taking on projects that both challenge and inspire. I've gained invaluable insights into system architecture, error handling, user input management, and the intricacies of low-level programming.

Moreover, I've experienced significant personal growth as a developer. The challenges I've faced and overcome have boosted my problem-solving skills and confidence in tackling complex projects.

## Looking Ahead

As I continue to develop MoldOS, I'm filled with excitement for what's to come. Each new feature and optimization brings me closer to my goal of creating a fully functional, unique operating system. Some areas I'm looking to explore include:

1.  Implementing a more advanced file system, possibly moving from FAT12 to a custom file system
2.  Developing a basic networking stack
3.  Creating a simple graphical user interface
4.  Expanding the capabilities of my in-OS game engine

I hope that sharing my journey inspires others to pursue their passion projects, no matter how daunting they might seem at first. Remember, every expert was once a beginner, and the key to growth is to keep learning, experimenting, and coding.

Thank you all for your support and encouragement along the way.

Happy coding, everyone!
